#version 450

layout (local_size_x = 32, local_size_y = 32) in;
layout (rgba32f, binding = 0) uniform image2D renderTexture;
layout (r32f, binding = 1) uniform image2D stepCountTexture;
layout (r32f, binding = 2) uniform image2D depthTexture;

uniform int shadowType;

uniform ivec2 resolution;
uniform int stepLimit;
uniform int shadowStepLimit;

uniform float time;
uniform float maxDrawDistance;

uniform vec3 cameraPosition;
uniform vec3 cameraFront;

uniform bool enableAmbientOcclusion;
uniform bool enableAntiAliasing;
uniform bool enableReflections;

uniform int maxReflections;

uniform float AA_size;

const vec3 lightPos = vec3(20, 25, 1 + cos(time / 10) * 100);// TODO

#define SHADES 0

#define EPSILON  0.0001
#define SHADOW_FALLOFF 0.01
#define SHADOW_OPACITY 0.8

struct RenderResult {
    vec4 color;
    float depth;
    int stepCount;
};
struct IntersectionResult {
    float minDist;
    float mat;
    int steps;
};


vec3 getCameraRayDir(vec2 coord, vec3 camPos, vec3 camForward) {
    const vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    const vec3 camUp = normalize(cross(camForward, camRight));
    const float fPersp = 2;// TODO
    const vec3 vDir = normalize(coord.x * camRight + coord.y * camUp + camForward * fPersp);
    return vDir;
}




vec2 distToObjects(vec3 camPos) {
    camPos = opRepLim(camPos, vec3(500.0, 1000.0, 500.0), vec3(10.0, 0.0, 10.0));
    return opBlend(
    opBlend(
    vec2(sdBox(camPos - vec3(0.0, -15.0, 0.0), vec3(30.0, 1.0, 30.0))), opBlend(
    vec2(sdSphere(camPos - vec3(0.0, 300.0, 0.0), 10.0)), vec2(sdBox(camPos - vec3(0.0, -12.0, 0.0), vec3(4.0, 300.0, 4.0))), 300.0
    ), 100.0
    ), vec2(sdPlane(camPos - vec3(0.0, -10.0, 0.0), vec4(0.0, 1.4, 0.0, 10.0))), 200.0
    );

    //return repeatingSphere(camPos, vec3(20) + time * 0.00000001);
    //return vec2(mengerSponge(camPos).x);
    //return vec2(camPos.y - sin(camPos.x  + time * 0.000000001) - sin(camPos.z));
    const float sphere1X = 3 + cos(time) * 5;
    vec2 d = vec2(sdSphere(camPos-vec3(sphere1X, -2.5, 10), 2.5));
    d = opBlend(d, vec2(sdSphere(camPos-vec3(-3, -2.5, 10), 2.5)), 20);
    d = opSubstraction(d, vec2(sdSphere(camPos-vec3(0, 2 + sin(time) * 5, 10), 2.5)));
    d = opUnion(d, vec2(sdPlane(camPos, vec4(0, 1.4, 0, 10))));
    //d = opBlend(d, vec2(sdPlane(camPos - vec3(5, 0, 0), vec4(1.4, 0, 0, 10))));

    vec3 repeatC = repeatCoord(camPos, vec3(100, 10, 100));
    vec2 a = vec2(sdBox(repeatC, vec3(5, 10, 5)));
    vec2 b = opIntersection(a, vec2(sdBox(camPos - vec3(0, -5 + cos(time) * 50, 0), vec3(1000, 10, 1000))));
    vec2 c = opIntersection(a, vec2(sdBox(camPos - vec3(0, -5 + sin(time) * 50, 0), vec3(1000, 10, 1000))));
    d = opSmoothSubtraction(c, d, 50);
    d = opBlend(d, b, 10);

    return d;
    //return repeatingSphere(camPos, vec3(20) + time * 0.00000001);
    //return vec2(sdSphere(camPos, vec3(3, -2.5, 10), 2.5));
    //return vec2(opRepeat(sdSphere(camPos, vec3(0, 0, 20), 2.5), 10.f));
}

IntersectionResult castRay(vec3 rayOrigin, vec3 rayDir) {
    float travelDistance = 0.0;
    IntersectionResult result;
    result.mat = -1.0;
    for (result.steps = 0; result.steps < stepLimit; result.steps++) {
        const vec2 res = distToObjects(rayOrigin + rayDir * travelDistance);
        travelDistance += res.x;
        result.mat = res.y;
        if (res.x < EPSILON) {
            //result.mat = -1;
            result.minDist = travelDistance;
            return result;
        } else if (travelDistance > maxDrawDistance) {
            result.mat = -1;
            result.minDist = -1.0;
            return result;
        }
    }
    result.minDist = travelDistance;
    return result;
}

IntersectionResult castRefrRay(vec3 rayOrigin, vec3 rayDir, float distanceFactor) {
    float travelDistance = 0.0;
    IntersectionResult result;
    result.mat = -1.0;
    for (result.steps = 0; result.steps < stepLimit; result.steps++) {
        const vec2 res = distanceFactor * distToObjects(rayOrigin + rayDir * travelDistance);
        travelDistance += res.x;
        result.mat = res.y;
        if (res.x < EPSILON) {
            //result.mat = -1;
            result.minDist = travelDistance;
            return result;
        } else if (travelDistance > maxDrawDistance) {
            result.mat = -1;
            result.minDist = -1.0;
            return result;
        }
    }
    result.minDist = travelDistance;
    return result;
}

IntersectionResult castReflRay(vec3 rayOrigin, vec3 rayDir) {
    float travelDistance = 0.0;
    IntersectionResult result;
    result.mat = -1.0;
    for (result.steps = 0; result.steps < stepLimit / 5; result.steps++) {
        const vec2 res = distToObjects(rayOrigin + rayDir * travelDistance);
        travelDistance += res.x;
        result.mat = res.y;
        if (res.x < EPSILON * 2) {
            //result.mat = -1;
            result.minDist = travelDistance;
            return result;
        } else if (travelDistance > maxDrawDistance) {
            result.mat = -1;
            result.minDist = -1.0;
            return result;
        }
    }
    result.minDist = travelDistance;
    return result;
}

    #define MAX_SCATTER_RAYS 50
vec3 castScatterRay(vec3 rayOrigin, vec3 rayDir) {
    vec3 objectSurfaceColour = vec3(0.4, 0.8, 0.1);
    vec3 density = pow(objectSurfaceColour, vec3(.6));
    vec3 visibility = vec3(1.);

    float lastVal = distToObjects(rayOrigin).x;
    float soft = 0.0;
    for (int i=1; i < MAX_SCATTER_RAYS; i++)
    {
        if (visibility.x < EPSILON)
        continue;

        float val = distToObjects(rayOrigin).x;

        vec3 softened = pow(density, vec3(smoothstep(soft, -soft, val)));
        //tweak this to create soft shadows, by expanding with each step (linearly)

        if ((val-soft)*lastVal < 0.0)
        {
            // approximate position of the surface
            float transition = -min(val-soft, lastVal)/abs(val-soft-lastVal);
            visibility *= pow(softened, vec3(transition));
        }
        else if (val-soft < 0.0)
        {
            visibility *= softened;
        }

        soft += .1;
        lastVal = val+soft;
        rayOrigin += rayDir*.4;
    }

    return visibility;
}

vec3 calcNormal(vec3 pos) {
    const float h = 0.001;
    const vec2 k = vec2(1, -1);
    return normalize(
    k.xyy * distToObjects(pos + k.xyy * h).x +
    k.yyx * distToObjects(pos + k.yyx * h).x +
    k.yxy * distToObjects(pos + k.yxy * h).x +
    k.xxx * distToObjects(pos + k.xxx * h).x
    );
}

float softshadow(vec3 rayOrigin, vec3 rayDirection, float minTravel, float maxTravel, float k) {
    float res = 1.0;
    float ph = 1e20;
    int i = 0;
    for (float t = minTravel; i < shadowStepLimit && t < maxTravel; i++) {
        const float h = distToObjects(rayOrigin + rayDirection * t).x;
        if (h < EPSILON) {
            return 0.0;
        }
        const float y = h * h / (2.0 * ph);
        const float d = sqrt(h * h - y * y);
        res = min(res, k * d / max(0.0, t - y));
        ph = h;
        t += h;
    }
    return clamp(res, 0.0, 1.0);
}

float getShadowMultiplier(vec3 rayEnd, vec3 lightDir, vec3 normal){
    vec3 rayDir = lightDir;
    return softshadow(rayEnd, normalize(rayDir), 0.01, maxDrawDistance, 50);
}

float getHardShadowMultiplier(vec3 rayOrigin, vec3 rayDirection, vec3 normal) {
    rayDirection = normalize(rayDirection);
    float minTravel = 0.01;
    float maxTravel = maxDrawDistance;
    int i = 0;
    for (float t = minTravel; i < shadowStepLimit && t < maxTravel; i++) {
        const float h = distToObjects(rayOrigin + rayDirection * t).x;
        if (h < EPSILON) {
            return 0.0;
        }
        t += h;
    }
    return 1.0;
}

float calcAO(vec3 pos, vec3 nor) {
    float occ = 0.0;
    float sca = 1.0;
    for (int i = 0; i < 5; i++) {
        const float h = 0.001 + 0.15 * float(i) / 4.0;
        const float d = distToObjects(pos + h * nor).x;
        occ += (h - d) * sca;
        sca *= 0.95;
    }
    return clamp(1.0 - 1.5 * occ, 0.0, 1.0);
}

vec3 shading(vec3 pos, vec3 normal, vec3 lightDir, vec3 rayDir, bool checkShadow) {
    vec3 col;
    float shadow = 0.0;
    float shadowRayCount = 2.0;
    if (checkShadow) {
        if (shadowType == 1) {
            for (float s = 0.0; s < shadowRayCount; s++)
            {
                vec3 shadowRayOrigin = pos + normal * 0.01;
                float r = rand(vec2(rayDir.xy)) * 2.0 - 1.0;
                vec3 shadowRayDir = lightDir + vec3(1.0 * SHADOW_FALLOFF) * r;
                IntersectionResult shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);
                if (shadowRayIntersection.mat != -1.0)
                {
                    shadow += 1.0;
                }
            }
        } else if (shadowType == 2) {
            shadow = getShadowMultiplier(pos + normal * 0.01, lightDir, normal);
        } else if (shadowType == 3) {
            shadow = getHardShadowMultiplier(pos + normal * 0.01, lightDir, normal);
        }
    } else {
        shadow = 1.0;
    }


    vec3 objectSurfaceColour = vec3(0.4, 0.8, 0.1);
    float NoL = max(dot(normal, lightDir), 0.0);
    vec3 LDirectional = vec3(0.9, 0.9, 0.8) * NoL;
    vec3 LAmbient = vec3(0.03, 0.04, 0.1);
    vec3 diffuse = (LDirectional + LAmbient);
    float specular = dot(normalize(lightPos-pos), reflect(normalize(pos-cameraPosition), normal));
    col = objectSurfaceColour;
    vec3 intensity;
    if (shadowType == 1) {
        intensity = diffuse + vec3(1.0)*(0.25*pow(clamp(specular, 0.0, 1.0), 200.0));
    } else if (shadowType != 0) {
        intensity = diffuse + clamp(shadow - 0.5, 0, 1)  * vec3(1.0)*(0.25*pow(clamp(specular, 0.0, 1.0), 200.0));
    } else {
        intensity = diffuse + vec3(1.0)*(0.25*pow(clamp(specular, 0.0, 1.0), 200.0));
    }

    if (shadowType == 1) {
        intensity *= 1 - shadow;
        //vec3 cshadow = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));
        //intensity = mix(col, col*cshadow*(1.0-SHADOW_OPACITY), shadow/shadowRayCount);
    } else if (shadowType == 2 || shadowType == 3) {
        intensity *= shadow;
    }

        #if SHADES != 0
    intensity = ceil(intensity * SHADES) / float(SHADES);
    #endif
    col *= intensity;
    return col;
}


vec4 subSurfaceShading(vec3 pos, vec3 normal, vec3 lightDir, vec3 rayDir, vec3 visibility) {
    vec3 albedo = vec3(1);//mix( vec3(1,.8,.7), vec3(.5,.2,.1), Noise(pos*vec3(1,10,1)) );
    const vec3 fillLightDir = vec3(0, 0, -1);
    const vec3 lightColour = vec3(1.1, 1.05, 1);
    const vec3 fillLightColour = vec3(.38, .4, .42);
    vec3 l = lightColour*mix(visibility, vec3(1)*max(0.0, dot(normal, normalize(lightDir))), .0);
    vec3 fl = fillLightColour*(dot(normal, normalize(fillLightDir))*.5+.5);

    vec3 view = normalize(-rayDir);
    vec3 h = normalize(view+lightDir);
    float specular = pow(max(0.0, dot(h, normal)), 2000.0);

    float fresnel = pow(1.0 - dot(view, normal), 5.0);
    fresnel = mix(.01, 1.0, min(1.0, fresnel));

    //fresnel = 0.0;

    return vec4(albedo*(l+fl)*(1.0-fresnel) + visibility*specular*32.0*lightColour, fresnel);
}

RenderResult renderRefraction(vec3 rayOrigin, vec3 rayDir) {
    float refractionRatio = 1.0 / 1.7;
    const int refractLimit = 50;
    float refractFactor = 0.6;

    vec3 col = vec3(0);
    vec3 lightDir = normalize(lightPos);
    float distanceFactor = 1.0;
    int stepCount = 0;
    int rayIndex = 0;
    float intensity = 1.0;
    for (rayIndex = 0; rayIndex < 15; rayIndex++) {
        IntersectionResult intersectionResult = castRefrRay(rayOrigin, rayDir, distanceFactor);
        stepCount += intersectionResult.steps;
        if (intersectionResult.minDist <= -1.0) {
            col = col * (1.0 - intensity) + (vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.7)) * intensity;
            break;
        } else {
            rayOrigin = rayOrigin + rayDir * intersectionResult.minDist;
            vec3 normal = distanceFactor * calcNormal(rayOrigin);

            if (distanceFactor > 0) {
                const vec3 objColor = shading(rayOrigin, normal, lightDir, rayDir, true);
                col = col * (1.0 - intensity) + objColor * intensity;
                intensity *= refractFactor;
            }

            vec3 refraction = refract(rayDir, normal, refractionRatio);
            if (dot(refraction, refraction) < EPSILON) {
                rayDir = reflect(rayDir, normal);
                rayOrigin += rayDir * EPSILON * 10.0;
            } else {
                rayDir = refraction;
                rayOrigin += rayDir * EPSILON * 10;
                distanceFactor = -distanceFactor;
                refractionRatio = 1.0 / refractionRatio;
            }
        }
    }
    RenderResult result;
    result.color = vec4(col / (0.6 * (rayIndex + 1)), 1);
    result.stepCount = stepCount;
    return result;
}

RenderResult renderScattering(vec3 rayOrigin, vec3 rayDir) {
    IntersectionResult intersectionResult = castRay(rayOrigin, rayDir);
    vec3 col;
    if (intersectionResult.minDist <= -1.0) {
        col = vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.7);
    } else {
        vec3 pos = rayOrigin + rayDir * intersectionResult.minDist;
        vec3 lightDir = normalize(lightPos);//-pos);
        vec3 normal = calcNormal(pos);


        vec3 subsurface = castScatterRay(pos + rayDir * 0.001, lightDir);
        col = subSurfaceShading(pos, normal, lightDir, rayDir, subsurface).xyz;

        //col = normal;
        //col = smoothstep(0.0,1.0,col);
        if (enableAmbientOcclusion) {
            //col *= (1.0-vec3(intersectionResult.steps/stepLimit));
            col *= calcAO(pos, normal);
        }
    }

    RenderResult result;
    result.color = vec4(col, 1);
    result.stepCount = intersectionResult.steps;
    result.depth = intersectionResult.minDist;
    return result;
}

RenderResult render(vec3 rayOrigin, vec3 rayDir) {
    return renderScattering(rayOrigin, rayDir);
    IntersectionResult intersectionResult = castRay(rayOrigin, rayDir);
    vec3 col;
    int steps = intersectionResult.steps;
    float depth = intersectionResult.minDist;
    if (intersectionResult.minDist <= -1.0) {
        col = vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.7);
    } else {
        vec3 pos = rayOrigin + rayDir * intersectionResult.minDist;
        vec3 lightDir = normalize(lightPos);//-pos);
        vec3 normal = calcNormal(pos);

        col = shading(pos, normal, lightDir, rayDir, true);

        if (enableReflections) {
            vec3 reflColor = vec3(0);
            int i = 0;
            for (i = 0; i < maxReflections; i++) {
                rayDir = reflect(rayDir, normal);
                IntersectionResult reflIntersectionResult = castReflRay(pos + rayDir * 0.001, rayDir);
                if (reflIntersectionResult.minDist > -1.0) {
                    pos = pos + rayDir * reflIntersectionResult.minDist;
                    normal = calcNormal(pos);
                    vec3 targetColor = shading(pos, normal, lightDir, rayDir, true);
                    reflColor += targetColor * 0.2;
                } else {
                    reflColor += (vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.7)) * 0.2;
                }
                steps += intersectionResult.steps;
            }
            col += reflColor / i;
        }

        //col = normal;
        //col = smoothstep(0.0,1.0,col);
        if (enableAmbientOcclusion) {
            //col *= (1.0-vec3(intersectionResult.steps/stepLimit));
            col *= calcAO(pos, normal);
        }
    }

    RenderResult result;
    result.color = vec4(col, 1);
    result.stepCount = steps;
    result.depth = depth;
    return result;
}

vec2 normalizeScreenCoords(vec2 screenCoord) {
    vec2 result = 2.0 * (screenCoord/resolution.xy - 0.5);
    result.x *= resolution.x/float(resolution.y);// Correct for aspect ratio
    return result;
}

float logNormalize(float enteredValue, float minEntry, float maxEntry, float normalizedMin, float normalizedMax) {

    float mx = (log((enteredValue-minEntry))/(log(maxEntry-minEntry)));
    float preshiftNormalized = mx*(normalizedMax-normalizedMin);
    float shiftedNormalized = preshiftNormalized + normalizedMin;

    return shiftedNormalized;
}

vec3 applyFog(in vec3  rgb, // original color of the pixel
in float distance, // camera to point distance
in vec3  rayOri, // camera position
in vec3  rayDir)// camera to point vector
{ ;
    float b = 0.05;
    float c = 0.2;
    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp(-distance*rayDir.y*b))/rayDir.y;
    vec3  fogColor  = vec3(0.5, 0.5, 0.5);
    return mix(rgb, fogColor, fogAmount);
}

void main() {
    if (gl_GlobalInvocationID.x >= resolution.x || gl_GlobalInvocationID.y >= resolution.y) {
        return;
    }
    const ivec2 texCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    RenderResult renderResult;
    vec2 screenCoord = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = normalizeScreenCoords(screenCoord);
    vec3 rayDir = getCameraRayDir(uv, cameraPosition, cameraFront);
    if (enableAntiAliasing) {
        vec4 resColor = vec4(0);
        float count = 0.0;
        for (float aaY = 0.0; aaY < AA_size; aaY++) {
            for (float aaX = 0.0; aaX < AA_size; aaX++) {
                vec2 uv = normalizeScreenCoords(screenCoord + vec2(aaX, aaY) / AA_size);
                rayDir = getCameraRayDir(uv, cameraPosition, cameraFront);
                renderResult = render(cameraPosition, rayDir);
                resColor += renderResult.color;
                count += 1.0;
            }
        }
        resColor /= count;
        renderResult.color = resColor;
    } else {
        renderResult = render(cameraPosition, rayDir);
    }
    renderResult.color = vec4(pow(renderResult.color.xyz, vec3(0.4545)), renderResult.color.w);
    vec2 q = vec2(texCoord) / vec2(resolution.xy);
    renderResult.color = vec4(renderResult.color.xyz * (0.8 + 0.3*sqrt(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y))), renderResult.color.w);
    float logStepColor = logNormalize(renderResult.stepCount, 0, stepLimit, 0, 1);
    float logDepth = logNormalize(renderResult.depth, 0, maxDrawDistance, 0, 1);
    float stepColor = renderResult.stepCount / float(64);
    //renderResult.color += stepColor * vec4(1, 0, 0, 0);

    imageStore(stepCountTexture, texCoord, vec4(logStepColor, 0, 0, 0));
    imageStore(renderTexture, texCoord, renderResult.color);
    imageStore(depthTexture, texCoord, vec4(logDepth, 0, 0, 0));
}