#version 450

layout (local_size_x = 1, local_size_y = 1) in;
layout (rgba32f, binding = 0) uniform image2D renderTexture;
layout (r32f, binding = 1) uniform image2D stepCountTexture;
layout (r32f, binding = 2) uniform image2D depthTexture;

uniform int stepLimit;
uniform vec3 cameraPosition;
uniform vec3 cameraTarget;

uniform float time;
uniform float maxDrawDistance;



struct IntersectionResult
{
    float minDist;
    float mat;
    int steps;
};


vec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)
{
    vec3 camForward = normalize(camTarget - camPos);
    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    vec3 camUp = normalize(cross(camForward, camRight));

    float fPersp = 2.0;
    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);

    return vDir;
}

vec2 distToObjects(vec3 camPos) {
    const float sphere1X = 3 + cos(time) * 5;
    vec2 d = vec2(sdSphere(camPos, vec3(sphere1X, -2.5, 10), 2.5));
    d = opBlend(d, vec2(sdSphere(camPos, vec3(-3, -2.5, 10), 2.5)));
    d = opBlend(d, vec2(sdSphere(camPos, vec3(0, 2, 10), 2.5)));
    d = opUnion(d, vec2(sdPlane(vec3(0), camPos, vec4(0, 1, 0, 5.5))));
    return d;
}


    #define FLT_MAX 3.402823466e+38
IntersectionResult castRay(vec3 rayOrigin, vec3 rayDir)
{
    float t = 0.0;// Stores current distance along ray

    IntersectionResult result;
    result.mat = -1.0;
    for (result.steps = 0; result.steps < stepLimit; result.steps++)
    {
        vec2 res = distToObjects(rayOrigin + rayDir * t);
        if (res.x < (0.0001*t))
        {
            result.minDist = t;
            return result;
        } else if (res.x > maxDrawDistance) {
            result.mat = -1.0;
            result.minDist = -1.0;
            return result;
        }
        result.mat = res.y;
        t += res.y;
    }
    result.minDist = t;
    return result;
}

vec3 calcNormal(vec3 pos)
{
    // Center sample
    float c = distToObjects(pos).x;
    // Use offset samples to compute gradient / normal
    vec2 eps_zero = vec2(0.001, 0.0);
    return normalize(vec3(distToObjects(pos + eps_zero.xyy).x, distToObjects(pos + eps_zero.yxy).x, distToObjects(pos + eps_zero.yyx).x) - c);
}

    #define SHADOW_FALLOFF 0.05
    #define SHADOW_OPACITY 0.8
vec3 render(vec3 rayOrigin, vec3 rayDir)
{
    const ivec2 texCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    IntersectionResult intersectionResult = castRay(rayOrigin, rayDir);

    vec3 col;
    if (intersectionResult.minDist <= -1.0)
    {
        // Skybox colour
        col = vec3(0.30, 0.36, 0.60) - (rayDir.y * 0.7);
    }
    else
    {
        //vec3 lightDir = normalize(vec3(1, cos(time * 0.5) + 0.5, -0.5));
        vec3 lightDir = normalize(vec3(1, 0.5, -0.5));
        vec3 pos = rayOrigin + rayDir * intersectionResult.minDist;
        vec3 normal = calcNormal(pos);

        vec3 objectSurfaceColour = vec3(0.4, 0.8, 0.1);
        float NoL = max(dot(normal, lightDir), 0.0);
        vec3 LDirectional = vec3(0.9, 0.9, 0.8) * NoL;
        vec3 LAmbient = vec3(0.03, 0.04, 0.1);
        vec3 diffuse = objectSurfaceColour * (LDirectional + LAmbient);


        float shadow = 0.0;
        float shadowRayCount = 2.0;
        for (float s = 0.0; s < shadowRayCount; s++)
        {
            vec3 shadowRayOrigin = pos + normal * 0.01;
            float r = rand(vec2(rayDir.xy)) * 2.0 - 1.0;
            vec3 shadowRayDir = lightDir + vec3(1.0 * SHADOW_FALLOFF) * r;
            IntersectionResult shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);
            if (shadowRayIntersection.mat != -1.0)
            {
                shadow += 1.0;
            }
        }
        col = diffuse;
        vec3 cshadow = pow(vec3(shadow), vec3(1.0, 1.2, 1.5));
        col = mix(col, col*cshadow*(1.0-SHADOW_OPACITY), shadow/shadowRayCount);


    }


    float stepColor = intersectionResult.steps / stepLimit;
    imageStore(stepCountTexture, texCoord, vec4(stepColor, 0, 0, 0));
    imageStore(renderTexture, texCoord, vec4(col, 1));
    imageStore(depthTexture, texCoord, vec4(intersectionResult.minDist, 0, 0, 0));
    return col;
}

vec2 normalizeScreenCoords(vec2 screenCoord)
{
    ivec2 resolution = imageSize(renderTexture);
    vec2 result = 2.0 * (screenCoord/resolution.xy - 0.5);
    result.x *= resolution.x/resolution.y; // Correct for aspect ratio
    return result;
}

void main() {
    vec3 camPos = vec3(0, 0, -15);
    vec3 camTarget = vec3(0, 0, 0);

    vec2 screenCoord = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec2 uv = normalizeScreenCoords(screenCoord);
    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);

    render(camPos, rayDir);


}