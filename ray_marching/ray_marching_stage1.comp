#version 450
layout (local_size_x = 8, local_size_y = 8) in;
layout (r32f, binding = 0) uniform image2D stepCountTexture;
layout (r32f, binding = 1) uniform image2D distanceTexture;

#define PIXEL_STEP 9
#define PIXEL_OFFSET int(PIXEL_STEP / 2)
uniform float pixelRadius;
uniform float relaxationParameter;
uniform ivec2 resolution;
uniform float maxDrawDistance;
uniform int stepLimit;
uniform vec3 cameraPosition;
uniform vec3 cameraFront;

const float macroPixelRadius = pixelRadius * (PIXEL_STEP + 1);


layout (std430, binding=0) buffer CSGTree {
    CSGNode csgTree[];
};
layout (std430, binding=1) buffer CSGParams {
    float csgParams[];
};
layout (std430, binding=2) buffer PostOrderStack {
    uint postOrderStack[];
};
float getFloatCSGParam(uint paramOffset) {
    return csgParams[paramOffset];
}
vec3 getVec3CSGParam(uint paramOffset) {
    return vec3(csgParams[paramOffset], csgParams[paramOffset + 1], csgParams[paramOffset + 2]);
}
vec4 getVec4CSGParam(uint paramOffset) {
    return vec4(csgParams[paramOffset], csgParams[paramOffset + 1], csgParams[paramOffset + 2], csgParams[paramOffset + 3]);
}

struct SSBOStack {
    int top;
};
SSBOStack initSSBOStack() {
    SSBOStack result;
    result.top = int(postOrderStack[0] - 1);
    return result;
}
    #define SSBO_STACK_TOP(stack) postOrderStack[1 + stack.top]
    #define SSBO_STACK_POP(stack) stack.top--
    #define SSBO_STACK_EMPTY(stack) bool(stack.top < 0)
    #define SSBO_STACK_RESET(stack) stack.top = int(postOrderStack[0] - 1);

float distToShape(vec3 camPos, CSGNode node) {
    const uint paramOffset = PARAM_OFFSET(node);
    switch (SHAPE_INDEX(node)) {
        case 0:
        return sdBox(camPos - getVec3CSGParam(paramOffset), getVec3CSGParam(paramOffset + 3));
        case 1:
        return sdSphere(camPos - getVec3CSGParam(paramOffset), getFloatCSGParam(paramOffset + 3));
        case 2:
        return sdPlane(camPos - getVec3CSGParam(paramOffset), getVec4CSGParam(paramOffset + 3));
    }
    return FLT_MAX;
}

float applyOperation(CSGNode node, float leftOperand, float rightOperand) {
    switch (OPERATION_INDEX(node)) {
        case 0:
        return opUnion(leftOperand, rightOperand);
        case 1:
        return opSubstraction(leftOperand, rightOperand);
        case 2:
        return opBlend(leftOperand, rightOperand, getFloatCSGParam(PARAM_OFFSET(node)));
    }
    return FLT_MAX;
}
vec3 applyWarpOperation(CSGNode node, vec3 camPos) {
    switch (OPERATION_INDEX(node)) {
        case 0:
        return opRep(camPos, getVec3CSGParam(PARAM_OFFSET(node)));
        case 1:
        return opRepLim(camPos, getVec3CSGParam(PARAM_OFFSET(node)), getVec3CSGParam(PARAM_OFFSET(node) + 3));
        case 2:
        return opStretch(camPos, getVec3CSGParam(PARAM_OFFSET(node)));
    }
    return vec3(FLT_MAX);
}

    #define VEC3_STACK STACK_TYPE_NAME(vec3, 3)
STACK(vec3, 3);
MAKE_STACK_INIT(VEC3_STACK);

#define FLOAT_STACK STACK_TYPE_NAME(float, 10)
STACK(float, 10);
MAKE_STACK_INIT(FLOAT_STACK);


SSBOStack postStack = initSSBOStack();
VEC3_STACK coordStack = STACK_INIT(VEC3_STACK);
FLOAT_STACK valueStack = STACK_INIT(FLOAT_STACK);

float mapCSG(vec3 camPos) {
    float result;
    STACK_RESET(valueStack);
    SSBO_STACK_RESET(postStack);

    float minShapeDist = FLT_MAX;
    int materialIndex = 0;
    while (!SSBO_STACK_EMPTY(postStack)) {
const uint nodeIndex = SSBO_STACK_TOP(postStack);
SSBO_STACK_POP(postStack);
const CSGNode node = csgTree[nodeIndex];
if (IS_COORD_LOAD(nodeIndex)) {
    camPos = STACK_TOP(coordStack);
    STACK_POP(coordStack);
} else if (IS_SHAPE(node)) {
    const float distance = distToShape(camPos, node);
    STACK_PUSH(valueStack, distance);
} else if (IS_BINARY_OP(node)){
    const float op2 = STACK_TOP(valueStack);
    STACK_POP(valueStack);
    const float op1 = STACK_TOP(valueStack);
    STACK_POP(valueStack);
    const float distance = applyOperation(node, op1, op2);
    STACK_PUSH(valueStack, distance);
} else /* if (IS_WARP_OP(node))*/ {
    STACK_PUSH(coordStack, camPos);
    camPos = applyWarpOperation(node, camPos);
}
}

result = STACK_TOP(valueStack);


return result;
}

vec2 rayMarch(Ray ray) {
    float travelDistance = 0;

    float candidate_error = FLT_MAX;
    float candidate_t = 0;
    float previousDistance = 0;
    float stepLength = 0;
    float omega = relaxationParameter;
    int i;
    for (i = 0; i < stepLimit; i++) {
        const float distance = mapCSG(ray.origin + travelDistance * ray.direction);
        const bool sorFail = omega > 1 && (distance + previousDistance) < stepLength;

        if (sorFail) {
            stepLength -= omega * stepLength;
            omega = 1;
        } else {
            stepLength = distance * omega;
        }

        previousDistance = distance;
        const float error = distance / travelDistance;

        if (!sorFail && error < candidate_error) {
            candidate_t = travelDistance;
            candidate_error = error;
        }

        travelDistance += stepLength;


        if (!sorFail && error < macroPixelRadius) {
            break;
        } else if (travelDistance > maxDrawDistance) {
            return vec2(0.0, float(i));
        }
    }
    return vec2(candidate_t * 0.95, float(i));
}

Ray[5] rays;
vec2 rayMarchMulti() {
    float travelDistance = 0;

    float candidate_error = FLT_MAX;
    float candidate_t = 0;
    float previousDistance = 0;
    float stepLength = 0;
    float omega = relaxationParameter;
    int i;
    for (i = 0; i < stepLimit; i++) {
        const vec3 rayPos = rays[2].origin + travelDistance * rays[2].direction;
        const float distance_ = mapCSG(rayPos);
        const bool sorFail = omega > 1 && (distance_ + previousDistance) < stepLength;
        float maxRayDistance = 0;
        for (int i = 0; i < 2; ++i) {
            const vec3 secondaryRayPos = rays[i].origin + travelDistance * rays[i].direction;
            const float d = distance(rayPos, secondaryRayPos);
            maxRayDistance = max(maxRayDistance, d);
        }
        for (int i = 3; i < 5; ++i) {
            const vec3 secondaryRayPos = rays[i].origin + travelDistance * rays[i].direction;
            const float d = distance(rayPos, secondaryRayPos);
            maxRayDistance = max(maxRayDistance, d);
        }

        if (sorFail) {
            stepLength -= omega * stepLength;
            omega = 1;
        } else {
            stepLength = distance_ * omega;
        }

        previousDistance = distance_;
        const float error = distance_ / travelDistance;

        if (!sorFail && error < candidate_error) {
            candidate_t = travelDistance;
        }


        travelDistance += stepLength;
        if (!sorFail && travelDistance > maxDrawDistance) {
            return vec2(-1, float(i));
        } else if (!sorFail && distance_ <= maxRayDistance + pixelRadius * travelDistance) {
            break;
        }
    }
    return vec2(travelDistance * 0.96, float(i));
}

vec2 normalizeScreenCoords(vec2 screenCoord) {
    vec2 result = 2.0 * (screenCoord/resolution.xy - 0.5);
    result.x *= resolution.x/float(resolution.y);
    return result;
}
vec3 getCameraRayDir(vec2 coord, vec3 camPos, vec3 camForward) {
    const vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));
    const vec3 camUp = normalize(cross(camForward, camRight));
    const float fPersp = 2;
    return normalize(coord.x * camRight + coord.y * camUp + camForward * fPersp);
}

void main() {
    const uint pixelOffset = PIXEL_STEP / 2;
    if (gl_GlobalInvocationID.x * PIXEL_STEP > resolution.x + PIXEL_STEP - pixelOffset || gl_GlobalInvocationID.y * PIXEL_STEP > resolution.y + PIXEL_STEP - pixelOffset) {
        return;
    }
    const ivec2 texCoord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    const ivec2 globalTexCoord = ivec2(gl_GlobalInvocationID.x * PIXEL_STEP + pixelOffset, gl_GlobalInvocationID.y * PIXEL_STEP + pixelOffset);
    vec2 screenCoord = vec2(gl_GlobalInvocationID.x * PIXEL_STEP + pixelOffset, gl_GlobalInvocationID.y * PIXEL_STEP + pixelOffset);
    vec2 uv = normalizeScreenCoords(screenCoord);

    Ray mainRay;
    mainRay.origin = cameraPosition;
    mainRay.direction = getCameraRayDir(uv, cameraPosition, cameraFront);
    rays[2] = mainRay;
    int cnt = 0;
    for (int y = -PIXEL_OFFSET; y < PIXEL_STEP; y += PIXEL_STEP - 1) {
        for (int x = -PIXEL_OFFSET; x < PIXEL_STEP; x += PIXEL_STEP - 1) {
            Ray ray;
            ray.origin = cameraPosition;
            vec2 uv = normalizeScreenCoords(screenCoord + vec2(x, y));
            ray.direction = getCameraRayDir(uv, cameraPosition, cameraFront);
            rays[cnt] = ray;
            ++cnt;
        }
        ++cnt;
    }

    vec2 distanceAndStepCount = rayMarchMulti();

    imageStore(distanceTexture, texCoord, vec4(distanceAndStepCount.x, 0, 0, 0));
    for (int y = -PIXEL_OFFSET; y < PIXEL_STEP; ++y) {
        for (int x = -PIXEL_OFFSET; x < PIXEL_STEP; ++x) {
            imageStore(stepCountTexture, globalTexCoord + ivec2(x, y), vec4(distanceAndStepCount.y, 0, 0, 0));
        }
    }
}